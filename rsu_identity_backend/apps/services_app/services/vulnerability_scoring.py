"""
ðŸ‡¬ðŸ‡¦ RSU GABON - SCORING VULNÃ‰RABILITÃ‰ AVANCÃ‰
Standards Top 1% - Intelligence Artificielle Contextuelle Gabon
====================================================================

SystÃ¨me de scoring multi-dimensionnel adaptÃ© au contexte socio-Ã©conomique gabonais
Conforme aux standards ID4D Principles et audit Banque Mondiale
"""

import logging
import numpy as np
from typing import Dict, List, Tuple, Optional
from decimal import Decimal
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class VulnerabilityLevel(Enum):
    """Niveaux de vulnÃ©rabilitÃ© selon standards gouvernementaux"""
    CRITICAL = "CRITICAL"      # 75-100: Intervention urgente
    HIGH = "HIGH"              # 50-74: Intervention prioritaire  
    MODERATE = "MODERATE"      # 25-49: Surveillance active
    LOW = "LOW"                # 0-24: Suivi rÃ©gulier

@dataclass
class DimensionScore:
    """Structure score par dimension"""
    dimension: str
    score: float
    weight: float
    contributing_factors: List[str]
    risk_indicators: List[str]
    recommendations: List[str]

@dataclass
class VulnerabilityAssessment:
    """Ã‰valuation complÃ¨te vulnÃ©rabilitÃ©"""
    global_score: float
    vulnerability_level: VulnerabilityLevel
    dimension_scores: Dict[str, DimensionScore]
    priority_interventions: List[str]
    social_programs_eligibility: Dict[str, float]
    geographic_priority_zone: str
    assessment_date: str
    confidence_score: float

class GabonVulnerabilityScoringEngine:
    """
    Moteur de scoring vulnÃ©rabilitÃ© contextualisÃ© Gabon
    Algorithme IA avec 5 dimensions prioritaires gouvernementales
    """
    
    # === SEUILS Ã‰CONOMIQUES GABON (FCFA) ===
    ECONOMIC_THRESHOLDS = {
        'EXTREME_POVERTY': 75_000,      # PauvretÃ© extrÃªme
        'POVERTY_LINE': 150_000,        # Seuil pauvretÃ© national
        'LOWER_MIDDLE': 300_000,        # Classe moyenne infÃ©rieure
        'MIDDLE_CLASS': 500_000,        # Classe moyenne
        'UPPER_MIDDLE': 1_000_000,      # Classe moyenne supÃ©rieure
    }
    
    # === PONDÃ‰RATIONS DIMENSIONS ===
    DIMENSION_WEIGHTS = {
        'economic': 0.30,      # Ã‰conomique (prioritÃ© gouvernementale)
        'social': 0.25,        # Social (Ã©ducation, santÃ©, rÃ©seaux)
        'demographic': 0.20,   # DÃ©mographique (Ã¢ge, genre, mÃ©nage)
        'geographic': 0.15,    # GÃ©ographique (accessibilitÃ©, isolement)
        'resilience': 0.10,    # RÃ©silience (chocs, adaptation)
    }
    
    # === PROVINCES GABON AVEC PRIORITÃ‰S ===
    PROVINCE_RISK_FACTORS = {
        'ESTUAIRE': {'base_score': 10, 'urban_density': 0.8},      # Libreville
        'HAUT_OGOOUE': {'base_score': 25, 'mining_economy': 0.7},  # Franceville
        'MOYEN_OGOOUE': {'base_score': 35, 'rural_isolation': 0.9}, # LambarÃ©nÃ©
        'NGOUNIER': {'base_score': 30, 'agricultural': 0.8},      # Mouila
        'NYANGA': {'base_score': 40, 'coastal_remote': 0.9},      # Tchibanga
        'OGOOUE_IVINDO': {'base_score': 45, 'forest_isolation': 1.0}, # Makokou
        'OGOOUE_LOLO': {'base_score': 35, 'logging_economy': 0.8}, # Koulamoutou
        'OGOOUE_MARITIME': {'base_score': 20, 'oil_economy': 0.6}, # Port-Gentil
        'WOLEU_NTEM': {'base_score': 30, 'border_region': 0.7},   # Oyem
    }

    def __init__(self):
        """Initialisation du moteur de scoring"""
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("ðŸ‡¬ðŸ‡¦ Initialisation moteur scoring vulnÃ©rabilitÃ© Gabon")

    def calculate_vulnerability_assessment(self, person_data: Dict) -> VulnerabilityAssessment:
        """
        Calcul complet Ã©valuation vulnÃ©rabilitÃ©
        
        Args:
            person_data: DonnÃ©es complÃ¨tes de la personne
            
        Returns:
            VulnerabilityAssessment: Ã‰valuation complÃ¨te
        """
        try:
            # 1. Calcul scores par dimension
            dimension_scores = {
                'economic': self._calculate_economic_dimension(person_data),
                'social': self._calculate_social_dimension(person_data),
                'demographic': self._calculate_demographic_dimension(person_data),
                'geographic': self._calculate_geographic_dimension(person_data),
                'resilience': self._calculate_resilience_dimension(person_data),
            }
            
            # 2. Score global pondÃ©rÃ©
            global_score = self._calculate_weighted_global_score(dimension_scores)
            
            # 3. Niveau vulnÃ©rabilitÃ©
            vulnerability_level = self._determine_vulnerability_level(global_score)
            
            # 4. Ã‰ligibilitÃ© programmes sociaux
            programs_eligibility = self._calculate_programs_eligibility(
                dimension_scores, global_score
            )
            
            # 5. Zone prioritÃ© gÃ©ographique
            geographic_priority = self._determine_geographic_priority(person_data)
            
            # 6. Interventions prioritaires
            priority_interventions = self._identify_priority_interventions(dimension_scores)
            
            # 7. Score confiance
            confidence_score = self._calculate_confidence_score(person_data)
            
            assessment = VulnerabilityAssessment(
                global_score=round(global_score, 2),
                vulnerability_level=vulnerability_level,
                dimension_scores=dimension_scores,
                priority_interventions=priority_interventions,
                social_programs_eligibility=programs_eligibility,
                geographic_priority_zone=geographic_priority,
                assessment_date=self._get_current_date(),
                confidence_score=confidence_score
            )
            
            self.logger.info(f"âœ… Ã‰valuation vulnÃ©rabilitÃ© calculÃ©e: {global_score:.2f}")
            return assessment
            
        except Exception as e:
            self.logger.error(f"âŒ Erreur calcul vulnÃ©rabilitÃ©: {e}")
            raise

    def _calculate_economic_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION Ã‰CONOMIQUE (30% du score)
        Indicateurs: revenus, emploi, logement, patrimoine
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. REVENUS MENSUELS (50% dimension Ã©conomique)
        monthly_income = data.get('monthly_income', 0)
        
        if monthly_income <= self.ECONOMIC_THRESHOLDS['EXTREME_POVERTY']:
            score += 50
            factors.append("PauvretÃ© extrÃªme (<75k FCFA/mois)")
            risks.append("InsÃ©curitÃ© alimentaire critique")
            recommendations.append("Transferts monÃ©taires d'urgence")
        elif monthly_income <= self.ECONOMIC_THRESHOLDS['POVERTY_LINE']:
            score += 35
            factors.append("Sous seuil pauvretÃ© (<150k FCFA/mois)")
            risks.append("VulnÃ©rabilitÃ© aux chocs Ã©conomiques")
            recommendations.append("Programme appui moyens subsistance")
        elif monthly_income <= self.ECONOMIC_THRESHOLDS['LOWER_MIDDLE']:
            score += 20
            factors.append("Revenus faibles (150-300k FCFA/mois)")
            risks.append("PrÃ©caritÃ© Ã©conomique")
            recommendations.append("Formation professionnelle")
        
        # 2. STATUT EMPLOI (25% dimension Ã©conomique)
        occupation = data.get('occupation', '').upper()
        
        if occupation in ['UNEMPLOYED', 'CHOMEUR']:
            score += 25
            factors.append("ChÃ´mage")
            risks.append("Exclusion sociale")
            recommendations.append("Programmes insertion professionnelle")
        elif occupation in ['INFORMAL', 'PETIT_COMMERCE']:
            score += 20
            factors.append("Emploi informel prÃ©caire")
            risks.append("Revenus irrÃ©guliers")
            recommendations.append("Formalisation activitÃ©s Ã©conomiques")
        elif occupation in ['FARMER', 'AGRICULTEUR', 'PECHEUR']:
            score += 15
            factors.append("Agriculture/pÃªche traditionnelle")
            risks.append("DÃ©pendance climat/saisons")
            recommendations.append("Diversification moyens subsistance")
        
        # 3. TYPE LOGEMENT (15% dimension Ã©conomique)
        housing_type = data.get('housing_type', '').upper()
        
        if housing_type in ['PRECARIOUS', 'BIDONVILLE', 'CASE_TRADITIONNELLE']:
            score += 15
            factors.append("Logement prÃ©caire")
            risks.append("Conditions vie insalubres")
            recommendations.append("Programme amÃ©lioration habitat")
        elif housing_type in ['RENTAL', 'LOCATION']:
            score += 8
            factors.append("Logement location")
            risks.append("InstabilitÃ© rÃ©sidentielle")
        
        # 4. ACCÃˆS SERVICES FINANCIERS (10% dimension Ã©conomique)
        has_bank_account = data.get('has_bank_account', False)
        if not has_bank_account:
            score += 10
            factors.append("Exclusion financiÃ¨re")
            risks.append("DifficultÃ©s Ã©pargne/crÃ©dit")
            recommendations.append("Inclusion financiÃ¨re digitale")
        
        return DimensionScore(
            dimension="economic",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['economic'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_social_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION SOCIALE (25% du score)
        Indicateurs: Ã©ducation, santÃ©, rÃ©seaux sociaux, inclusion
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. NIVEAU Ã‰DUCATION (40% dimension sociale)
        education_level = data.get('education_level', '').upper()
        
        if education_level in ['NONE', 'AUCUN', 'ILLITERATE']:
            score += 40
            factors.append("Aucune Ã©ducation formelle")
            risks.append("Exclusion numÃ©rique et sociale")
            recommendations.append("AlphabÃ©tisation adultes")
        elif education_level in ['PRIMARY', 'PRIMAIRE']:
            score += 25
            factors.append("Ã‰ducation primaire seulement")
            risks.append("OpportunitÃ©s emploi limitÃ©es")
            recommendations.append("Formation professionnelle adaptÃ©e")
        elif education_level in ['SECONDARY', 'SECONDAIRE']:
            score += 10
            factors.append("Ã‰ducation secondaire")
            recommendations.append("Formation continue")
        
        # 2. ACCÃˆS SOINS SANTÃ‰ (30% dimension sociale)
        health_insurance = data.get('has_health_insurance', False)
        distance_health_center = data.get('distance_health_center_km', 50)
        
        if not health_insurance:
            score += 20
            factors.append("Pas d'assurance santÃ©")
            risks.append("BarriÃ¨res financiÃ¨res soins")
            recommendations.append("Couverture santÃ© universelle")
        
        if distance_health_center > 30:
            score += 15
            factors.append(f"Centre santÃ© Ã©loignÃ© ({distance_health_center}km)")
            risks.append("AccÃ¨s difficile soins urgents")
            recommendations.append("UnitÃ©s mobiles santÃ©")
        elif distance_health_center > 15:
            score += 8
            factors.append("AccÃ¨s santÃ© limitÃ©")
            recommendations.append("AmÃ©lioration transport santÃ©")
        
        # 3. RÃ‰SEAUX SOCIAUX (20% dimension sociale)
        social_support = data.get('social_support_network', 'WEAK').upper()
        
        if social_support in ['NONE', 'AUCUN']:
            score += 20
            factors.append("Isolation sociale")
            risks.append("VulnÃ©rabilitÃ© psychosociale")
            recommendations.append("Groupes entraide communautaire")
        elif social_support in ['WEAK', 'FAIBLE']:
            score += 12
            factors.append("RÃ©seaux sociaux faibles")
            risks.append("Support limitÃ© en cas crise")
            recommendations.append("Renforcement liens communautaires")
        
        # 4. HANDICAP/VULNÃ‰RABILITÃ‰S SPÃ‰CIALES (10% dimension sociale)
        has_disability = data.get('has_disability', False)
        if has_disability:
            score += 10
            factors.append("Handicap/vulnÃ©rabilitÃ© spÃ©ciale")
            risks.append("Discrimination et exclusion")
            recommendations.append("Programmes inclusion handicap")
        
        return DimensionScore(
            dimension="social",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['social'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_demographic_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION DÃ‰MOGRAPHIQUE (20% du score)
        Indicateurs: Ã¢ge, genre, structure mÃ©nage, dÃ©pendance
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. Ã‚GE VULNÃ‰RABLE (30% dimension dÃ©mographique)
        age = data.get('age', 30)
        
        if age < 5:
            score += 25
            factors.append("Enfant petite enfance (<5 ans)")
            risks.append("Malnutrition et mortalitÃ© infantile")
            recommendations.append("Programmes nutrition mÃ¨re-enfant")
        elif age < 18:
            score += 15
            factors.append("Enfant/adolescent (<18 ans)")
            risks.append("DÃ©scolarisation et travail prÃ©coce")
            recommendations.append("Protection enfance et scolarisation")
        elif age > 65:
            score += 20
            factors.append("Personne Ã¢gÃ©e (>65 ans)")
            risks.append("Isolement et soins inadÃ©quats")
            recommendations.append("Programmes soins personnes Ã¢gÃ©es")
        
        # 2. GENRE ET RESPONSABILITÃ‰S (25% dimension dÃ©mographique)
        gender = data.get('gender', '').upper()
        is_household_head = data.get('is_household_head', False)
        marital_status = data.get('marital_status', '').upper()
        
        if gender == 'F' and is_household_head:
            score += 20
            factors.append("Femme chef de mÃ©nage")
            risks.append("Charge familiale et discrimination")
            recommendations.append("Appui femmes chefs de mÃ©nage")
        
        if marital_status in ['WIDOW', 'VEUVE', 'DIVORCED', 'DIVORCEE']:
            score += 15
            factors.append("Veuvage/divorce")
            risks.append("Perte support Ã©conomique")
            recommendations.append("Aide sociale spÃ©cialisÃ©e")
        
        # 3. STRUCTURE MÃ‰NAGE (25% dimension dÃ©mographique)
        household_size = data.get('household_size', 4)
        dependents_count = data.get('dependents_count', 0)
        
        if household_size > 10:
            score += 15
            factors.append(f"MÃ©nage trÃ¨s Ã©tendu ({household_size} membres)")
            risks.append("Ressources diluÃ©es")
            recommendations.append("Appui mÃ©nages Ã©tendus")
        elif household_size > 7:
            score += 8
            factors.append("MÃ©nage Ã©tendu")
            recommendations.append("Soutien Ã©conomique ciblÃ©")
        
        # Ratio de dÃ©pendance
        if household_size > 0:
            dependency_ratio = dependents_count / household_size
            if dependency_ratio > 0.6:
                score += 12
                factors.append("Ratio dÃ©pendance Ã©levÃ©")
                risks.append("Charge Ã©conomique excessive")
                recommendations.append("Transferts ciblÃ©s dÃ©pendants")
        
        # 4. GROSSESSE/ALLAITEMENT (20% dimension dÃ©mographique)
        is_pregnant = data.get('is_pregnant', False)
        is_breastfeeding = data.get('is_breastfeeding', False)
        
        if is_pregnant or is_breastfeeding:
            score += 12
            factors.append("Grossesse/allaitement")
            risks.append("Besoins nutritionnels accrus")
            recommendations.append("Programmes santÃ© maternelle")
        
        return DimensionScore(
            dimension="demographic",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['demographic'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_geographic_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION GÃ‰OGRAPHIQUE (15% du score)
        Indicateurs: localisation, accessibilitÃ©, infrastructures
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. PROVINCE ET Ã‰LOIGNEMENT (40% dimension gÃ©ographique)
        province = data.get('province', 'ESTUAIRE').upper()
        province_factors = self.PROVINCE_RISK_FACTORS.get(province, {'base_score': 25})
        
        base_score = province_factors['base_score']
        score += base_score
        
        if base_score >= 40:
            factors.append(f"Province isolÃ©e ({province})")
            risks.append("AccÃ¨s limitÃ© services publics")
            recommendations.append("Programmes dÃ©veloppement rural")
        elif base_score >= 25:
            factors.append(f"Province pÃ©riphÃ©rique ({province})")
            recommendations.append("AmÃ©lioration infrastructures")
        
        # 2. TYPE ZONE (30% dimension gÃ©ographique)
        zone_type = data.get('zone_type', 'RURAL').upper()
        
        if zone_type in ['RURAL_REMOTE', 'FORET_ISOLEE']:
            score += 30
            factors.append("Zone rurale trÃ¨s isolÃ©e")
            risks.append("Exclusion numÃ©rique et physique")
            recommendations.append("Infrastructures connectivitÃ©")
        elif zone_type in ['RURAL', 'RURAL_ACCESSIBLE']:
            score += 20
            factors.append("Zone rurale")
            risks.append("Services limitÃ©s")
            recommendations.append("Services publics mobiles")
        elif zone_type in ['URBAN_PERIPHERY', 'PERIURBAIN']:
            score += 10
            factors.append("PÃ©riphÃ©rie urbaine")
            recommendations.append("Extension services urbains")
        
        # 3. ACCESSIBILITÃ‰ TRANSPORT (20% dimension gÃ©ographique)
        road_access = data.get('road_access_type', 'DIRT').upper()
        
        if road_access in ['FOOTPATH', 'SENTIER', 'NONE']:
            score += 20
            factors.append("Pas d'accÃ¨s routier")
            risks.append("Isolement total en saison pluies")
            recommendations.append("Infrastructures transport de base")
        elif road_access in ['DIRT', 'TERRE_BATTUE']:
            score += 12
            factors.append("AccÃ¨s routier prÃ©caire")
            risks.append("Coupure saisonniÃ¨re")
            recommendations.append("AmÃ©lioration routes rurales")
        elif road_access in ['GRAVEL', 'LATERITE']:
            score += 6
            factors.append("Route latÃ©rite")
            recommendations.append("Bitumage prioritaire")
        
        # 4. SERVICES PROXIMITÃ‰ (10% dimension gÃ©ographique)
        distance_services = data.get('distance_nearest_town_km', 50)
        
        if distance_services > 100:
            score += 10
            factors.append("Services trÃ¨s Ã©loignÃ©s (>100km)")
            risks.append("Urgences mÃ©dicales compromises")
            recommendations.append("Centres services dÃ©centralisÃ©s")
        elif distance_services > 50:
            score += 6
            factors.append("Services Ã©loignÃ©s")
            recommendations.append("Transport public amÃ©liorÃ©")
        
        return DimensionScore(
            dimension="geographic",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['geographic'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_resilience_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION RÃ‰SILIENCE (10% du score)
        Indicateurs: exposition chocs, mÃ©canismes adaptation, rÃ©cupÃ©ration
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. EXPOSITION AUX CHOCS (40% dimension rÃ©silience)
        climate_exposure = data.get('climate_shock_exposure', 'MEDIUM').upper()
        economic_shocks = data.get('economic_shock_history', False)
        
        if climate_exposure in ['HIGH', 'ELEVE']:
            score += 25
            factors.append("Forte exposition chocs climatiques")
            risks.append("Pertes agricoles rÃ©currentes")
            recommendations.append("Adaptation changement climatique")
        elif climate_exposure in ['MEDIUM', 'MOYEN']:
            score += 15
            factors.append("Exposition modÃ©rÃ©e aux chocs")
            recommendations.append("MÃ©canismes prÃ©vention")
        
        if economic_shocks:
            score += 15
            factors.append("Historique chocs Ã©conomiques")
            risks.append("VulnÃ©rabilitÃ© cycles Ã©conomiques")
            recommendations.append("Diversification revenus")
        
        # 2. MÃ‰CANISMES ADAPTATION (35% dimension rÃ©silience)
        savings = data.get('has_savings', False)
        diversified_income = data.get('diversified_income_sources', False)
        
        if not savings:
            score += 20
            factors.append("Aucune Ã©pargne")
            risks.append("Pas de coussin sÃ©curitÃ©")
            recommendations.append("Programmes Ã©pargne communautaire")
        
        if not diversified_income:
            score += 15
            factors.append("Revenus non diversifiÃ©s")
            risks.append("DÃ©pendance source unique")
            recommendations.append("DÃ©veloppement activitÃ©s secondaires")
        
        # 3. CAPACITÃ‰ RÃ‰CUPÃ‰RATION (25% dimension rÃ©silience)
        recovery_time_last_shock = data.get('recovery_time_months', 12)
        
        if recovery_time_last_shock > 24:
            score += 15
            factors.append("RÃ©cupÃ©ration trÃ¨s lente (>2 ans)")
            risks.append("Spirale appauvrissement")
            recommendations.append("Aide relÃ¨vement d'urgence")
        elif recovery_time_last_shock > 12:
            score += 10
            factors.append("RÃ©cupÃ©ration lente (>1 an)")
            recommendations.append("Appui reconstruction")
        
        return DimensionScore(
            dimension="resilience",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['resilience'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_weighted_global_score(self, dimension_scores: Dict[str, DimensionScore]) -> float:
        """Calcul score global pondÃ©rÃ©"""
        weighted_sum = sum(
            score.score * score.weight
            for score in dimension_scores.values()
        )
        return round(weighted_sum, 2)

    def _determine_vulnerability_level(self, global_score: float) -> VulnerabilityLevel:
        """DÃ©termine niveau vulnÃ©rabilitÃ© selon seuils gouvernementaux"""
        if global_score >= 75:
            return VulnerabilityLevel.CRITICAL
        elif global_score >= 50:
            return VulnerabilityLevel.HIGH
        elif global_score >= 25:
            return VulnerabilityLevel.MODERATE
        else:
            return VulnerabilityLevel.LOW

    def _calculate_programs_eligibility(self, dimension_scores: Dict[str, DimensionScore], 
                                      global_score: float) -> Dict[str, float]:
        """
        Calcul Ã©ligibilitÃ© programmes sociaux selon scores dimensions
        """
        eligibility = {}
        
        # Programme Transferts MonÃ©taires
        economic_score = dimension_scores['economic'].score
        if economic_score >= 35:
            eligibility['transferts_monetaires'] = min(economic_score * 1.2, 100.0)
        
        # Programme Nutrition Maternelle
        demographic_score = dimension_scores['demographic'].score
        if demographic_score >= 25:
            eligibility['nutrition_maternelle'] = min(demographic_score * 1.1, 100.0)
        
        # Programme DÃ©veloppement Rural
        geographic_score = dimension_scores['geographic'].score
        if geographic_score >= 30:
            eligibility['developpement_rural'] = min(geographic_score * 1.15, 100.0)
        
        # Programme Formation Professionnelle
        social_score = dimension_scores['social'].score
        if social_score >= 20:
            eligibility['formation_professionnelle'] = min(social_score * 1.05, 100.0)
        
        # Programme Aide d'Urgence
        if global_score >= 70:
            eligibility['aide_urgence'] = min(global_score * 1.1, 100.0)
        
        return eligibility

    def _determine_geographic_priority(self, data: Dict) -> str:
        """DÃ©termine zone prioritÃ© gÃ©ographique"""
        province = data.get('province', 'ESTUAIRE').upper()
        zone_type = data.get('zone_type', 'RURAL').upper()
        
        province_factors = self.PROVINCE_RISK_FACTORS.get(province, {'base_score': 25})
        
        if province_factors['base_score'] >= 40 and 'REMOTE' in zone_type:
            return 'CRITICAL_PRIORITY'
        elif province_factors['base_score'] >= 30:
            return 'HIGH_PRIORITY'
        elif province_factors['base_score'] >= 20:
            return 'MEDIUM_PRIORITY'
        else:
            return 'LOW_PRIORITY'

    def _identify_priority_interventions(self, dimension_scores: Dict[str, DimensionScore]) -> List[str]:
        """Identifie interventions prioritaires selon scores Ã©levÃ©s"""
        interventions = []
        
        # Trier dimensions par score dÃ©croissant
        sorted_dimensions = sorted(
            dimension_scores.items(),
            key=lambda x: x[1].score,
            reverse=True
        )
        
        for dimension_name, dimension_score in sorted_dimensions:
            if dimension_score.score >= 50:
                interventions.extend(dimension_score.recommendations[:2])  # Top 2 recommandations
                
        return interventions[:5]  # Max 5 interventions prioritaires

    def _calculate_confidence_score(self, data: Dict) -> float:
        """
        Calcul score confiance basÃ© sur complÃ©tude donnÃ©es
        """
        required_fields = [
            'monthly_income', 'occupation', 'education_level', 'age', 'gender',
            'household_size', 'province', 'zone_type', 'housing_type'
        ]
        
        present_fields = sum(1 for field in required_fields if data.get(field) is not None)
        completeness = present_fields / len(required_fields)
        
        # Score confiance: 60% complÃ©tude + 40% cohÃ©rence
        coherence_score = self._check_data_coherence(data)
        confidence = (completeness * 0.6) + (coherence_score * 0.4)
        
        return round(confidence * 100, 1)

    def _check_data_coherence(self, data: Dict) -> float:
        """VÃ©rifie cohÃ©rence des donnÃ©es"""
        coherence_score = 1.0
        
        # CohÃ©rence revenu/emploi
        income = data.get('monthly_income', 0)
        occupation = data.get('occupation', '').upper()
        
        if occupation == 'UNEMPLOYED' and income > 50000:
            coherence_score -= 0.2
        
        # CohÃ©rence Ã¢ge/Ã©ducation
        age = data.get('age', 30)
        education = data.get('education_level', '').upper()
        
        if age < 10 and education in ['SECONDARY', 'TERTIARY']:
            coherence_score -= 0.3
            
        return max(coherence_score, 0.0)

    def _get_current_date(self) -> str:
        """Retourne date actuelle formatÃ©e"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d")

# === EXEMPLE D'UTILISATION ===
if __name__ == "__main__":
    # DonnÃ©es test personne vulnÃ©rable
    test_person = {
        'age': 28,
        'gender': 'F',
        'is_household_head': True,
        'marital_status': 'WIDOW',
        'monthly_income': 60000,  # Sous seuil pauvretÃ© extrÃªme
        'occupation': 'FARMER',
        'education_level': 'PRIMARY',
        'household_size': 8,
        'dependents_count': 5,
        'has_health_insurance': False,
        'distance_health_center_km': 45,
        'has_bank_account': False,
        'housing_type': 'CASE_TRADITIONNELLE',
        'province': 'OGOOUE_IVINDO',  # Province isolÃ©e forÃªt
        'zone_type': 'RURAL_REMOTE',
        'road_access_type': 'DIRT',
        'distance_nearest_town_km': 80,
        'climate_shock_exposure': 'HIGH',
        'has_savings': False,
        'diversified_income_sources': False,
        'recovery_time_months': 30,
        'social_support_network': 'WEAK',
        'is_pregnant': True,
    }
    
    # Initialisation moteur
    scoring_engine = GabonVulnerabilityScoringEngine()
    
    # Calcul Ã©valuation complÃ¨te
    assessment = scoring_engine.calculate_vulnerability_assessment(test_person)
    
    # Affichage rÃ©sultats
    print("ðŸ‡¬ðŸ‡¦ Ã‰VALUATION VULNÃ‰RABILITÃ‰ RSU GABON")
    print("=" * 50)
    print(f"Score Global: {assessment.global_score}/100")
    print(f"Niveau: {assessment.vulnerability_level.value}")
    print(f"Zone PrioritÃ©: {assessment.geographic_priority_zone}")
    print(f"Confiance: {assessment.confidence_score}%")
    print()
    
    print("ðŸ“Š SCORES PAR DIMENSION:")
    for dim_name, dim_score in assessment.dimension_scores.items():
        print(f"  {dim_name.upper()}: {dim_score.score:.1f}/100 (poids: {dim_score.weight:.0%})")
    print()
    
    print("ðŸŽ¯ INTERVENTIONS PRIORITAIRES:")
    for intervention in assessment.priority_interventions:
        print(f"  â€¢ {intervention}")
    print()
    
    print("ðŸ“‹ Ã‰LIGIBILITÃ‰ PROGRAMMES SOCIAUX:")
    for program, eligibility in assessment.social_programs_eligibility.items():
        print(f"  â€¢ {program}: {eligibility:.1f}% Ã©ligible")
    print()
    
    print("âš ï¸ FACTEURS DE RISQUE IDENTIFIÃ‰S:")
    for dim_name, dim_score in assessment.dimension_scores.items():
        if dim_score.score >= 30:  # Dimensions Ã  risque
            print(f"  {dim_name.upper()}:")
            for factor in dim_score.contributing_factors:
                print(f"    - {factor}")
    print()
    
    print("ðŸ’¡ RECOMMANDATIONS:")
    for dim_name, dim_score in assessment.dimension_scores.items():
        if dim_score.recommendations:
            print(f"  {dim_name.upper()}:")
            for rec in dim_score.recommendations[:2]:  # Top 2 recommandations
                print(f"    â†’ {rec}")
    
    print("\nâœ… Ã‰valuation terminÃ©e - Conforme standards gouvernementaux Gabon")