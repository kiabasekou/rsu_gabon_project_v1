"""
üá¨üá¶ RSU Gabon - Vulnerability Assessment Views
Standards Top 1% - APIs √âvaluation Vuln√©rabilit√©
Fichier: rsu_identity_backend/apps/services_app/views/vulnerability_views.py
"""

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db.models import Q, Count, Avg
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import filters

from apps.services_app.models import VulnerabilityAssessment
from apps.services_app.serializers import VulnerabilityAssessmentSerializer
from apps.services_app.services.vulnerability_service import VulnerabilityService
from apps.core_app.permissions import IsSurveyorOrHigher


class VulnerabilityAssessmentViewSet(viewsets.ModelViewSet):
    """
    ViewSet pour gestion √©valuations vuln√©rabilit√©
    
    Endpoints:
    - GET /vulnerability-assessments/ - Liste √©valuations
    - POST /vulnerability-assessments/ - Cr√©er √©valuation
    - GET /vulnerability-assessments/{id}/ - D√©tail
    - PUT/PATCH /vulnerability-assessments/{id}/ - Modifier
    - DELETE /vulnerability-assessments/{id}/ - Supprimer
    - POST /vulnerability-assessments/calculate/ - Calculer pour personne
    - GET /vulnerability-assessments/statistics/ - Statistiques globales
    """
    
    queryset = VulnerabilityAssessment.objects.all().select_related(
        'person', 'assessed_by'
    ).order_by('-assessment_date')
    
    serializer_class = VulnerabilityAssessmentSerializer
    permission_classes = [IsAuthenticated, IsSurveyorOrHigher]
    
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['risk_level', 'person__province']
    search_fields = ['person__first_name', 'person__last_name', 'person__rsu_id']
    ordering_fields = ['assessment_date', 'vulnerability_score']
    
    def get_queryset(self):
        """Filtrage optionnel par query params"""
        queryset = super().get_queryset()
        
        # Filtrer par score minimum
        min_score = self.request.query_params.get('min_score')
        if min_score:
            queryset = queryset.filter(vulnerability_score__gte=min_score)
        
        # Filtrer par score maximum
        max_score = self.request.query_params.get('max_score')
        if max_score:
            queryset = queryset.filter(vulnerability_score__lte=max_score)
        
        # Filtrer par date
        date_from = self.request.query_params.get('date_from')
        if date_from:
            queryset = queryset.filter(assessment_date__gte=date_from)
        
        date_to = self.request.query_params.get('date_to')
        if date_to:
            queryset = queryset.filter(assessment_date__lte=date_to)
        
        return queryset
    
    @action(detail=False, methods=['post'])
    def calculate(self, request):
        """
        Calculer √©valuation vuln√©rabilit√© pour une personne
        
        Body:
        {
            "person_id": 123,
            "force_recalculate": false
        }
        
        Returns:
            VulnerabilityAssessment cr√©√©e ou existante
        """
        person_id = request.data.get('person_id')
        force_recalculate = request.data.get('force_recalculate', False)
        
        if not person_id:
            return Response(
                {'error': 'person_id requis'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            service = VulnerabilityService()
            assessment = service.calculate_and_save_assessment(
                person_id=person_id,
                assessed_by=request.user,
                force_recalculate=force_recalculate
            )
            
            serializer = self.get_serializer(assessment)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
            
        except ValueError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {'error': f'Erreur calcul: {str(e)}'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=False, methods=['post'])
    def bulk_calculate(self, request):
        """
        Calculer √©valuations pour plusieurs personnes
        
        Body:
        {
            "person_ids": [123, 456, 789],
            "force_recalculate": false
        }
        
        Returns:
            {
                "success": 3,
                "failed": 0,
                "assessments": [...]
            }
        """
        person_ids = request.data.get('person_ids', [])
        force_recalculate = request.data.get('force_recalculate', False)
        
        if not person_ids or not isinstance(person_ids, list):
            return Response(
                {'error': 'person_ids requis (liste)'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        service = VulnerabilityService()
        results = {'success': 0, 'failed': 0, 'assessments': [], 'errors': []}
        
        for person_id in person_ids:
            try:
                assessment = service.calculate_and_save_assessment(
                    person_id=person_id,
                    assessed_by=request.user,
                    force_recalculate=force_recalculate
                )
                results['success'] += 1
                results['assessments'].append(self.get_serializer(assessment).data)
            except Exception as e:
                results['failed'] += 1
                results['errors'].append({
                    'person_id': person_id,
                    'error': str(e)
                })
        
        return Response(results, status=status.HTTP_200_OK)
    
    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """
        Statistiques globales √©valuations vuln√©rabilit√©
        
        Returns:
            {
                "total": 1000,
                "by_risk_level": {...},
                "avg_score": 45.5,
                "by_province": [...]
            }
        """
        queryset = self.get_queryset()
        
        # Total
        total = queryset.count()
        
        # Par niveau de risque
        by_risk_level = queryset.values('risk_level').annotate(
            count=Count('id'),
            avg_score=Avg('vulnerability_score')
        ).order_by('risk_level')
        
        # Score moyen global
        avg_score = queryset.aggregate(avg=Avg('vulnerability_score'))['avg'] or 0
        
        # Par province
        by_province = queryset.values('person__province').annotate(
            count=Count('id'),
            avg_score=Avg('vulnerability_score')
        ).order_by('-count')
        
        return Response({
            'total': total,
            'by_risk_level': {
                item['risk_level']: {
                    'count': item['count'],
                    'avg_score': round(float(item['avg_score'] or 0), 2)
                }
                for item in by_risk_level
            },
            'avg_score': round(float(avg_score), 2),
            'by_province': [
                {
                    'province': item['person__province'],
                    'count': item['count'],
                    'avg_score': round(float(item['avg_score'] or 0), 2)
                }
                for item in by_province
            ]
        })
    
    @action(detail=False, methods=['get'])
    def critical_cases(self, request):
        """
        Liste des cas CRITICAL n√©cessitant intervention urgente
        
        Returns:
            Liste √©valuations avec risk_level=CRITICAL
        """
        critical = self.get_queryset().filter(risk_level='CRITICAL')
        
        page = self.paginate_queryset(critical)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(critical, many=True)
        return Response(serializer.data)